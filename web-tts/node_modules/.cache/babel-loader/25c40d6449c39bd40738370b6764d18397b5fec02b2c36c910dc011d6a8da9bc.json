{"ast":null,"code":"import { ExtensionType, settings, extensions as extensions$1 } from \"@pixi/core\";\nlet storedGl, extensions;\nfunction getCompressedTextureExtensions() {\n  extensions = {\n    s3tc: storedGl.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n    s3tc_sRGB: storedGl.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n    /* eslint-disable-line camelcase */\n    etc: storedGl.getExtension(\"WEBGL_compressed_texture_etc\"),\n    etc1: storedGl.getExtension(\"WEBGL_compressed_texture_etc1\"),\n    pvrtc: storedGl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || storedGl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n    atc: storedGl.getExtension(\"WEBGL_compressed_texture_atc\"),\n    astc: storedGl.getExtension(\"WEBGL_compressed_texture_astc\")\n  };\n}\nconst detectCompressedTextures = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 2\n  },\n  test: async () => {\n    const gl = settings.ADAPTER.createCanvas().getContext(\"webgl\");\n    return gl ? (storedGl = gl, !0) : (console.warn(\"WebGL not available for compressed textures.\"), !1);\n  },\n  add: async formats => {\n    extensions || getCompressedTextureExtensions();\n    const textureFormats = [];\n    for (const extensionName in extensions) extensions[extensionName] && textureFormats.push(extensionName);\n    return [...textureFormats, ...formats];\n  },\n  remove: async formats => (extensions || getCompressedTextureExtensions(), formats.filter(f => !(f in extensions)))\n};\nextensions$1.add(detectCompressedTextures);\nexport { detectCompressedTextures };","map":{"version":3,"names":["storedGl","extensions","getCompressedTextureExtensions","s3tc","getExtension","s3tc_sRGB","etc","etc1","pvrtc","atc","astc","detectCompressedTextures","extension","type","ExtensionType","DetectionParser","priority","test","gl","settings","ADAPTER","createCanvas","getContext","console","warn","add","formats","textureFormats","extensionName","push","remove","filter","f","extensions$1"],"sources":["C:\\Users\\Owner\\Desktop\\python\\TTS-systeam\\voice\\web-tts\\node_modules\\pixi.js\\node_modules\\@pixi\\compressed-textures\\src\\loaders\\detectCompressedTextures.ts"],"sourcesContent":["import { extensions as ext, ExtensionType, settings } from '@pixi/core';\n\nimport type { FormatDetectionParser } from '@pixi/assets';\nimport type { CompressedTextureExtensionRef, CompressedTextureExtensions } from './compressedTextureExtensions';\n\nlet storedGl: WebGLRenderingContext;\nlet extensions: Partial<CompressedTextureExtensions>;\n\nfunction getCompressedTextureExtensions()\n{\n    extensions = {\n        s3tc: storedGl.getExtension('WEBGL_compressed_texture_s3tc'),\n        s3tc_sRGB: storedGl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), /* eslint-disable-line camelcase */\n        etc: storedGl.getExtension('WEBGL_compressed_texture_etc'),\n        etc1: storedGl.getExtension('WEBGL_compressed_texture_etc1'),\n        pvrtc: storedGl.getExtension('WEBGL_compressed_texture_pvrtc')\n            || storedGl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n        atc: storedGl.getExtension('WEBGL_compressed_texture_atc'),\n        astc: storedGl.getExtension('WEBGL_compressed_texture_astc')\n    } as Partial<CompressedTextureExtensions>;\n}\n\nexport const detectCompressedTextures = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 2,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        // Auto-detect WebGL compressed-texture extensions\n        const canvas = settings.ADAPTER.createCanvas();\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            if (process.env.DEBUG)\n            {\n                console.warn('WebGL not available for compressed textures.');\n            }\n\n            return false;\n        }\n\n        storedGl = gl;\n\n        return true;\n    },\n    add: async (formats: string[]): Promise<string[]> =>\n    {\n        if (!extensions) getCompressedTextureExtensions();\n\n        const textureFormats = [];\n\n        // Assign all available compressed-texture formats\n        for (const extensionName in extensions)\n        {\n            const extension = extensions[extensionName as CompressedTextureExtensionRef];\n\n            if (!extension)\n            {\n                continue;\n            }\n\n            textureFormats.push(extensionName);\n        }\n\n        return [...textureFormats, ...formats];\n    },\n    remove: async (formats: string[]): Promise<string[]> =>\n    {\n        if (!extensions) getCompressedTextureExtensions();\n\n        return formats.filter((f) => !(f in extensions));\n    },\n} as FormatDetectionParser;\n\next.add(detectCompressedTextures);\n"],"mappings":";AAKA,IAAIA,QAAA,EACAC,UAAA;AAEJ,SAASC,+BAAA,EACT;EACiBD,UAAA;IACTE,IAAA,EAAMH,QAAA,CAASI,YAAA,CAAa,+BAA+B;IAC3DC,SAAA,EAAWL,QAAA,CAASI,YAAA,CAAa,oCAAoC;IAAA;IACrEE,GAAA,EAAKN,QAAA,CAASI,YAAA,CAAa,8BAA8B;IACzDG,IAAA,EAAMP,QAAA,CAASI,YAAA,CAAa,+BAA+B;IAC3DI,KAAA,EAAOR,QAAA,CAASI,YAAA,CAAa,gCAAgC,KACtDJ,QAAA,CAASI,YAAA,CAAa,uCAAuC;IACpEK,GAAA,EAAKT,QAAA,CAASI,YAAA,CAAa,8BAA8B;IACzDM,IAAA,EAAMV,QAAA,CAASI,YAAA,CAAa,+BAA+B;EAAA;AAEnE;AAEO,MAAMO,wBAAA,GAA2B;EACpCC,SAAA,EAAW;IACPC,IAAA,EAAMC,aAAA,CAAcC,eAAA;IACpBC,QAAA,EAAU;EACd;EACAC,IAAA,EAAM,MAAAA,CAAA,KACN;IAGI,MAAMC,EAAA,GADSC,QAAA,CAASC,OAAA,CAAQC,YAAA,CAAa,EAC3BC,UAAA,CAAW,OAAO;IAEpC,OAAKJ,EAAA,IAULlB,QAAA,GAAWkB,EAAA,EAEJ,OARCK,OAAA,CAAQC,IAAA,CAAK,8CAA8C,GAGxD;EAMf;EACAC,GAAA,EAAK,MAAOC,OAAA,IACZ;IACSzB,UAAA,IAAYC,8BAAA,CAA+B;IAEhD,MAAMyB,cAAA,GAAiB;IAGvB,WAAWC,aAAA,IAAiB3B,UAAA,EAENA,UAAA,CAAW2B,aAA8C,KAO3ED,cAAA,CAAeE,IAAA,CAAKD,aAAa;IAGrC,OAAO,CAAC,GAAGD,cAAA,EAAgB,GAAGD,OAAO;EACzC;EACAI,MAAA,EAAQ,MAAOJ,OAAA,KAENzB,UAAA,IAAYC,8BAAA,CAA+B,GAEzCwB,OAAA,CAAQK,MAAA,CAAQC,CAAA,IAAM,EAAEA,CAAA,IAAK/B,UAAA,CAAW;AAEvD;AAEAgC,YAAA,CAAIR,GAAA,CAAId,wBAAwB"},"metadata":{},"sourceType":"module","externalDependencies":[]}