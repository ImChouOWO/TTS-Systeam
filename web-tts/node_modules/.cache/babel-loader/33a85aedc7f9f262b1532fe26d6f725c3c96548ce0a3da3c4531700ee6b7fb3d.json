{"ast":null,"code":"import { INTERNAL_FORMATS, INTERNAL_FORMAT_TO_BYTES_PER_PIXEL } from \"../const.mjs\";\nimport \"../resources/index.mjs\";\nimport { CompressedTextureResource } from \"../resources/CompressedTextureResource.mjs\";\nconst DDS_MAGIC_SIZE = 4,\n  DDS_HEADER_SIZE = 124,\n  DDS_HEADER_PF_SIZE = 32,\n  DDS_HEADER_DX10_SIZE = 20,\n  DDS_MAGIC = 542327876,\n  DDS_FIELDS = {\n    SIZE: 1,\n    FLAGS: 2,\n    HEIGHT: 3,\n    WIDTH: 4,\n    MIPMAP_COUNT: 7,\n    PIXEL_FORMAT: 19\n  },\n  DDS_PF_FIELDS = {\n    SIZE: 0,\n    FLAGS: 1,\n    FOURCC: 2,\n    RGB_BITCOUNT: 3,\n    R_BIT_MASK: 4,\n    G_BIT_MASK: 5,\n    B_BIT_MASK: 6,\n    A_BIT_MASK: 7\n  },\n  DDS_DX10_FIELDS = {\n    DXGI_FORMAT: 0,\n    RESOURCE_DIMENSION: 1,\n    MISC_FLAG: 2,\n    ARRAY_SIZE: 3,\n    MISC_FLAGS2: 4\n  },\n  PF_FLAGS = 1,\n  DDPF_ALPHA = 2,\n  DDPF_FOURCC = 4,\n  DDPF_RGB = 64,\n  DDPF_YUV = 512,\n  DDPF_LUMINANCE = 131072,\n  FOURCC_DXT1 = 827611204,\n  FOURCC_DXT3 = 861165636,\n  FOURCC_DXT5 = 894720068,\n  FOURCC_DX10 = 808540228,\n  DDS_RESOURCE_MISC_TEXTURECUBE = 4,\n  FOURCC_TO_FORMAT = {\n    [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n    [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n    [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT\n  },\n  DXGI_TO_FORMAT = {\n    // WEBGL_compressed_texture_s3tc\n    70: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n    71: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n    73: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n    74: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n    76: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n    77: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n    // WEBGL_compressed_texture_s3tc_srgb\n    72: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n    75: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n    78: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\n  };\nfunction parseDDS(arrayBuffer) {\n  const data = new Uint32Array(arrayBuffer);\n  if (data[0] !== DDS_MAGIC) throw new Error(\"Invalid DDS file magic word\");\n  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT),\n    height = header[DDS_FIELDS.HEIGHT],\n    width = header[DDS_FIELDS.WIDTH],\n    mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT],\n    pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT),\n    formatFlags = pixelFormat[PF_FLAGS];\n  if (formatFlags & DDPF_FOURCC) {\n    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];\n    if (fourCC !== FOURCC_DX10) {\n      const internalFormat2 = FOURCC_TO_FORMAT[fourCC],\n        dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE,\n        texData = new Uint8Array(arrayBuffer, dataOffset2);\n      return [new CompressedTextureResource(texData, {\n        format: internalFormat2,\n        width,\n        height,\n        levels: mipmapCount\n        // CompressedTextureResource will separate the levelBuffers for us!\n      })];\n    }\n    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE,\n      dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT),\n      dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT],\n      resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION],\n      miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG],\n      arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE],\n      internalFormat = DXGI_TO_FORMAT[dxgiFormat];\n    if (internalFormat === void 0) throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);\n    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) throw new Error(\"DDSParser does not support cubemap textures\");\n    if (resourceDimension === 6) throw new Error(\"DDSParser does not supported 3D texture data\");\n    const imageBuffers = new Array(),\n      dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;\n    if (arraySize === 1) imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));else {\n      const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];\n      let imageSize = 0,\n        levelWidth = width,\n        levelHeight = height;\n      for (let i = 0; i < mipmapCount; i++) {\n        const alignedLevelWidth = Math.max(1, levelWidth + 3 & -4),\n          alignedLevelHeight = Math.max(1, levelHeight + 3 & -4),\n          levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;\n        imageSize += levelSize, levelWidth = levelWidth >>> 1, levelHeight = levelHeight >>> 1;\n      }\n      let imageOffset = dataOffset;\n      for (let i = 0; i < arraySize; i++) imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize)), imageOffset += imageSize;\n    }\n    return imageBuffers.map(buffer => new CompressedTextureResource(buffer, {\n      format: internalFormat,\n      width,\n      height,\n      levels: mipmapCount\n    }));\n  }\n  throw formatFlags & DDPF_RGB ? new Error(\"DDSParser does not support uncompressed texture data.\") : formatFlags & DDPF_YUV ? new Error(\"DDSParser does not supported YUV uncompressed texture data.\") : formatFlags & DDPF_LUMINANCE ? new Error(\"DDSParser does not support single-channel (lumninance) texture data!\") : formatFlags & DDPF_ALPHA ? new Error(\"DDSParser does not support single-channel (alpha) texture data!\") : new Error(\"DDSParser failed to load a texture file due to an unknown reason!\");\n}\nexport { parseDDS };","map":{"version":3,"names":["DDS_MAGIC_SIZE","DDS_HEADER_SIZE","DDS_HEADER_PF_SIZE","DDS_HEADER_DX10_SIZE","DDS_MAGIC","DDS_FIELDS","SIZE","FLAGS","HEIGHT","WIDTH","MIPMAP_COUNT","PIXEL_FORMAT","DDS_PF_FIELDS","FOURCC","RGB_BITCOUNT","R_BIT_MASK","G_BIT_MASK","B_BIT_MASK","A_BIT_MASK","DDS_DX10_FIELDS","DXGI_FORMAT","RESOURCE_DIMENSION","MISC_FLAG","ARRAY_SIZE","MISC_FLAGS2","PF_FLAGS","DDPF_ALPHA","DDPF_FOURCC","DDPF_RGB","DDPF_YUV","DDPF_LUMINANCE","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_DX10","DDS_RESOURCE_MISC_TEXTURECUBE","FOURCC_TO_FORMAT","INTERNAL_FORMATS","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","DXGI_TO_FORMAT","COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT","parseDDS","arrayBuffer","data","Uint32Array","Error","header","BYTES_PER_ELEMENT","height","width","mipmapCount","pixelFormat","formatFlags","fourCC","internalFormat2","dataOffset2","texData","Uint8Array","CompressedTextureResource","format","levels","dx10Offset","dx10Header","buffer","dxgiFormat","resourceDimension","miscFlag","arraySize","internalFormat","imageBuffers","Array","dataOffset","push","pixelSize","INTERNAL_FORMAT_TO_BYTES_PER_PIXEL","imageSize","levelWidth","levelHeight","i","alignedLevelWidth","Math","max","alignedLevelHeight","levelSize","imageOffset","map"],"sources":["C:\\Users\\Owner\\Desktop\\python\\TTS-systeam\\voice\\web-tts\\node_modules\\pixi.js\\node_modules\\@pixi\\compressed-textures\\src\\parsers\\parseDDS.ts"],"sourcesContent":["import { INTERNAL_FORMAT_TO_BYTES_PER_PIXEL, INTERNAL_FORMATS } from '../const';\nimport { CompressedTextureResource } from '../resources';\n\nconst DDS_MAGIC_SIZE = 4;\nconst DDS_HEADER_SIZE = 124;\nconst DDS_HEADER_PF_SIZE = 32;\nconst DDS_HEADER_DX10_SIZE = 20;\n\n// DDS file format magic word\nconst DDS_MAGIC = 0x20534444;\n\n/**\n * DWORD offsets of the DDS file header fields (relative to file start).\n * @ignore\n */\nconst DDS_FIELDS = {\n    SIZE: 1,\n    FLAGS: 2,\n    HEIGHT: 3,\n    WIDTH: 4,\n    MIPMAP_COUNT: 7,\n    PIXEL_FORMAT: 19,\n};\n\n/**\n * DWORD offsets of the DDS PIXEL_FORMAT fields.\n * @ignore\n */\nconst DDS_PF_FIELDS = {\n    SIZE: 0,\n    FLAGS: 1,\n    FOURCC: 2,\n    RGB_BITCOUNT: 3,\n    R_BIT_MASK: 4,\n    G_BIT_MASK: 5,\n    B_BIT_MASK: 6,\n    A_BIT_MASK: 7\n};\n\n/**\n * DWORD offsets of the DDS_HEADER_DX10 fields.\n * @ignore\n */\nconst DDS_DX10_FIELDS = {\n    DXGI_FORMAT: 0,\n    RESOURCE_DIMENSION: 1,\n    MISC_FLAG: 2,\n    ARRAY_SIZE: 3,\n    MISC_FLAGS2: 4\n};\n\n/**\n * @see https://docs.microsoft.com/en-us/windows/win32/api/dxgiformat/ne-dxgiformat-dxgi_format\n * This is way over-blown for us! Lend us a hand, and remove the ones that aren't used (but set the remaining\n * ones to their correct value)\n * @ignore\n */\nenum DXGI_FORMAT\n    {\n    DXGI_FORMAT_UNKNOWN,\n    DXGI_FORMAT_R32G32B32A32_TYPELESS,\n    DXGI_FORMAT_R32G32B32A32_FLOAT,\n    DXGI_FORMAT_R32G32B32A32_UINT,\n    DXGI_FORMAT_R32G32B32A32_SINT,\n    DXGI_FORMAT_R32G32B32_TYPELESS,\n    DXGI_FORMAT_R32G32B32_FLOAT,\n    DXGI_FORMAT_R32G32B32_UINT,\n    DXGI_FORMAT_R32G32B32_SINT,\n    DXGI_FORMAT_R16G16B16A16_TYPELESS,\n    DXGI_FORMAT_R16G16B16A16_FLOAT,\n    DXGI_FORMAT_R16G16B16A16_UNORM,\n    DXGI_FORMAT_R16G16B16A16_UINT,\n    DXGI_FORMAT_R16G16B16A16_SNORM,\n    DXGI_FORMAT_R16G16B16A16_SINT,\n    DXGI_FORMAT_R32G32_TYPELESS,\n    DXGI_FORMAT_R32G32_FLOAT,\n    DXGI_FORMAT_R32G32_UINT,\n    DXGI_FORMAT_R32G32_SINT,\n    DXGI_FORMAT_R32G8X24_TYPELESS,\n    DXGI_FORMAT_D32_FLOAT_S8X24_UINT,\n    DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS,\n    DXGI_FORMAT_X32_TYPELESS_G8X24_UINT,\n    DXGI_FORMAT_R10G10B10A2_TYPELESS,\n    DXGI_FORMAT_R10G10B10A2_UNORM,\n    DXGI_FORMAT_R10G10B10A2_UINT,\n    DXGI_FORMAT_R11G11B10_FLOAT,\n    DXGI_FORMAT_R8G8B8A8_TYPELESS,\n    DXGI_FORMAT_R8G8B8A8_UNORM,\n    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,\n    DXGI_FORMAT_R8G8B8A8_UINT,\n    DXGI_FORMAT_R8G8B8A8_SNORM,\n    DXGI_FORMAT_R8G8B8A8_SINT,\n    DXGI_FORMAT_R16G16_TYPELESS,\n    DXGI_FORMAT_R16G16_FLOAT,\n    DXGI_FORMAT_R16G16_UNORM,\n    DXGI_FORMAT_R16G16_UINT,\n    DXGI_FORMAT_R16G16_SNORM,\n    DXGI_FORMAT_R16G16_SINT,\n    DXGI_FORMAT_R32_TYPELESS,\n    DXGI_FORMAT_D32_FLOAT,\n    DXGI_FORMAT_R32_FLOAT,\n    DXGI_FORMAT_R32_UINT,\n    DXGI_FORMAT_R32_SINT,\n    DXGI_FORMAT_R24G8_TYPELESS,\n    DXGI_FORMAT_D24_UNORM_S8_UINT,\n    DXGI_FORMAT_R24_UNORM_X8_TYPELESS,\n    DXGI_FORMAT_X24_TYPELESS_G8_UINT,\n    DXGI_FORMAT_R8G8_TYPELESS,\n    DXGI_FORMAT_R8G8_UNORM,\n    DXGI_FORMAT_R8G8_UINT,\n    DXGI_FORMAT_R8G8_SNORM,\n    DXGI_FORMAT_R8G8_SINT,\n    DXGI_FORMAT_R16_TYPELESS,\n    DXGI_FORMAT_R16_FLOAT,\n    DXGI_FORMAT_D16_UNORM,\n    DXGI_FORMAT_R16_UNORM,\n    DXGI_FORMAT_R16_UINT,\n    DXGI_FORMAT_R16_SNORM,\n    DXGI_FORMAT_R16_SINT,\n    DXGI_FORMAT_R8_TYPELESS,\n    DXGI_FORMAT_R8_UNORM,\n    DXGI_FORMAT_R8_UINT,\n    DXGI_FORMAT_R8_SNORM,\n    DXGI_FORMAT_R8_SINT,\n    DXGI_FORMAT_A8_UNORM,\n    DXGI_FORMAT_R1_UNORM,\n    DXGI_FORMAT_R9G9B9E5_SHAREDEXP,\n    DXGI_FORMAT_R8G8_B8G8_UNORM,\n    DXGI_FORMAT_G8R8_G8B8_UNORM,\n    DXGI_FORMAT_BC1_TYPELESS,\n    DXGI_FORMAT_BC1_UNORM,\n    DXGI_FORMAT_BC1_UNORM_SRGB,\n    DXGI_FORMAT_BC2_TYPELESS,\n    DXGI_FORMAT_BC2_UNORM,\n    DXGI_FORMAT_BC2_UNORM_SRGB,\n    DXGI_FORMAT_BC3_TYPELESS,\n    DXGI_FORMAT_BC3_UNORM,\n    DXGI_FORMAT_BC3_UNORM_SRGB,\n    DXGI_FORMAT_BC4_TYPELESS,\n    DXGI_FORMAT_BC4_UNORM,\n    DXGI_FORMAT_BC4_SNORM,\n    DXGI_FORMAT_BC5_TYPELESS,\n    DXGI_FORMAT_BC5_UNORM,\n    DXGI_FORMAT_BC5_SNORM,\n    DXGI_FORMAT_B5G6R5_UNORM,\n    DXGI_FORMAT_B5G5R5A1_UNORM,\n    DXGI_FORMAT_B8G8R8A8_UNORM,\n    DXGI_FORMAT_B8G8R8X8_UNORM,\n    DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM,\n    DXGI_FORMAT_B8G8R8A8_TYPELESS,\n    DXGI_FORMAT_B8G8R8A8_UNORM_SRGB,\n    DXGI_FORMAT_B8G8R8X8_TYPELESS,\n    DXGI_FORMAT_B8G8R8X8_UNORM_SRGB,\n    DXGI_FORMAT_BC6H_TYPELESS,\n    DXGI_FORMAT_BC6H_UF16,\n    DXGI_FORMAT_BC6H_SF16,\n    DXGI_FORMAT_BC7_TYPELESS,\n    DXGI_FORMAT_BC7_UNORM,\n    DXGI_FORMAT_BC7_UNORM_SRGB,\n    DXGI_FORMAT_AYUV,\n    DXGI_FORMAT_Y410,\n    DXGI_FORMAT_Y416,\n    DXGI_FORMAT_NV12,\n    DXGI_FORMAT_P010,\n    DXGI_FORMAT_P016,\n    DXGI_FORMAT_420_OPAQUE,\n    DXGI_FORMAT_YUY2,\n    DXGI_FORMAT_Y210,\n    DXGI_FORMAT_Y216,\n    DXGI_FORMAT_NV11,\n    DXGI_FORMAT_AI44,\n    DXGI_FORMAT_IA44,\n    DXGI_FORMAT_P8,\n    DXGI_FORMAT_A8P8,\n    DXGI_FORMAT_B4G4R4A4_UNORM,\n    DXGI_FORMAT_P208,\n    DXGI_FORMAT_V208,\n    DXGI_FORMAT_V408,\n    DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE,\n    DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE,\n    DXGI_FORMAT_FORCE_UINT\n}\n\n/**\n * Possible values of the field {@link DDS_DX10_FIELDS.RESOURCE_DIMENSION}\n * @ignore\n */\nenum D3D10_RESOURCE_DIMENSION\n    {\n    DDS_DIMENSION_TEXTURE1D = 2,\n    DDS_DIMENSION_TEXTURE2D = 3,\n    DDS_DIMENSION_TEXTURE3D = 6\n}\n\nconst PF_FLAGS = 1;\n\n// PIXEL_FORMAT flags\nconst DDPF_ALPHA = 0x2;\nconst DDPF_FOURCC = 0x4;\nconst DDPF_RGB = 0x40;\nconst DDPF_YUV = 0x200;\nconst DDPF_LUMINANCE = 0x20000;\n\n// Four character codes for DXTn formats\nconst FOURCC_DXT1 = 0x31545844;\nconst FOURCC_DXT3 = 0x33545844;\nconst FOURCC_DXT5 = 0x35545844;\nconst FOURCC_DX10 = 0x30315844;\n\n// Cubemap texture flag (for DDS_DX10_FIELDS.MISC_FLAG)\nconst DDS_RESOURCE_MISC_TEXTURECUBE = 0x4;\n\n/**\n * Maps `FOURCC_*` formats to internal formats (see {@link PIXI.INTERNAL_FORMATS}).\n * @ignore\n */\nconst FOURCC_TO_FORMAT: { [id: number]: number } = {\n    [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n    [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n    [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT\n};\n\n/**\n * Maps {@link DXGI_FORMAT} to types/internal-formats (see {@link PIXI.TYPES}, {@link PIXI.INTERNAL_FORMATS})\n * @ignore\n */\nconst DXGI_TO_FORMAT: { [id: number]: number } = {\n    // WEBGL_compressed_texture_s3tc\n    [DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n    [DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n    [DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n    [DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n    [DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n    [DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n\n    // WEBGL_compressed_texture_s3tc_srgb\n    [DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n    [DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n    [DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\n};\n\n/**\n * Parses the DDS file header, generates base-textures, and puts them into the texture cache.\n * @see https://docs.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide\n * @param arrayBuffer\n * @memberof PIXI\n */\nexport function parseDDS(arrayBuffer: ArrayBuffer): CompressedTextureResource[]\n{\n    const data = new Uint32Array(arrayBuffer);\n    const magicWord = data[0];\n\n    if (magicWord !== DDS_MAGIC)\n    {\n        throw new Error('Invalid DDS file magic word');\n    }\n\n    const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n\n    // DDS header fields\n    const height = header[DDS_FIELDS.HEIGHT];\n    const width = header[DDS_FIELDS.WIDTH];\n    const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];\n\n    // PIXEL_FORMAT fields\n    const pixelFormat = new Uint32Array(\n        arrayBuffer,\n        DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,\n        DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n    const formatFlags = pixelFormat[PF_FLAGS];\n\n    // File contains compressed texture(s)\n    if (formatFlags & DDPF_FOURCC)\n    {\n        const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];\n\n        // File contains one DXTn compressed texture\n        if (fourCC !== FOURCC_DX10)\n        {\n            const internalFormat = FOURCC_TO_FORMAT[fourCC];\n\n            const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;\n            const texData = new Uint8Array(arrayBuffer, dataOffset);\n\n            const resource = new CompressedTextureResource(texData, {\n                format: internalFormat,\n                width,\n                height,\n                levels: mipmapCount // CompressedTextureResource will separate the levelBuffers for us!\n            });\n\n            return [resource];\n        }\n\n        // FOURCC_DX10 indicates there is a 20-byte DDS_HEADER_DX10 after DDS_HEADER\n        const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;\n        const dx10Header = new Uint32Array(\n            data.buffer,\n            dx10Offset,\n            DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n        const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];\n        const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];\n        const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];\n        const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];\n\n        // Map dxgiFormat to PIXI.INTERNAL_FORMATS\n        const internalFormat = DXGI_TO_FORMAT[dxgiFormat];\n\n        if (internalFormat === undefined)\n        {\n            throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);\n        }\n        if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE)\n        {\n            // FIXME: Anybody excited about cubemap compressed textures?\n            throw new Error('DDSParser does not support cubemap textures');\n        }\n        if (resourceDimension === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)\n        {\n            // FIXME: Anybody excited about 3D compressed textures?\n            throw new Error('DDSParser does not supported 3D texture data');\n        }\n\n        // Uint8Array buffers of image data, including all mipmap levels in each image\n        const imageBuffers = new Array<Uint8Array>();\n        const dataOffset = DDS_MAGIC_SIZE\n                + DDS_HEADER_SIZE\n                + DDS_HEADER_DX10_SIZE;\n\n        if (arraySize === 1)\n        {\n            // No need bothering with the imageSize calculation!\n            imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));\n        }\n        else\n        {\n            // Calculate imageSize for each texture, and then locate each image's texture data\n\n            const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];\n            let imageSize = 0;\n            let levelWidth = width;\n            let levelHeight = height;\n\n            for (let i = 0; i < mipmapCount; i++)\n            {\n                const alignedLevelWidth = Math.max(1, (levelWidth + 3) & ~3);\n                const alignedLevelHeight = Math.max(1, (levelHeight + 3) & ~3);\n\n                const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;\n\n                imageSize += levelSize;\n\n                levelWidth = levelWidth >>> 1;\n                levelHeight = levelHeight >>> 1;\n            }\n\n            let imageOffset = dataOffset;\n\n            // NOTE: Cubemaps have 6-images per texture (but they aren't supported so ^_^)\n            for (let i = 0; i < arraySize; i++)\n            {\n                imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));\n                imageOffset += imageSize;\n            }\n        }\n\n        // Uint8Array -> CompressedTextureResource, and we're done!\n        return imageBuffers.map((buffer) => new CompressedTextureResource(buffer, {\n            format: internalFormat,\n            width,\n            height,\n            levels: mipmapCount\n        }));\n    }\n    if (formatFlags & DDPF_RGB)\n    {\n        // FIXME: We might want to allow uncompressed *.dds files?\n        throw new Error('DDSParser does not support uncompressed texture data.');\n    }\n    if (formatFlags & DDPF_YUV)\n    {\n        // FIXME: Does anybody need this feature?\n        throw new Error('DDSParser does not supported YUV uncompressed texture data.');\n    }\n    if (formatFlags & DDPF_LUMINANCE)\n    {\n        // FIXME: Microsoft says older DDS filers use this feature! Probably not worth the effort!\n        throw new Error('DDSParser does not support single-channel (lumninance) texture data!');\n    }\n    if (formatFlags & DDPF_ALPHA)\n    {\n        // FIXME: I'm tired! See above =)\n        throw new Error('DDSParser does not support single-channel (alpha) texture data!');\n    }\n\n    throw new Error('DDSParser failed to load a texture file due to an unknown reason!');\n}\n\n"],"mappings":";;;AAGA,MAAMA,cAAA,GAAiB;EACjBC,eAAA,GAAkB;EAClBC,kBAAA,GAAqB;EACrBC,oBAAA,GAAuB;EAGvBC,SAAA,GAAY;EAMZC,UAAA,GAAa;IACfC,IAAA,EAAM;IACNC,KAAA,EAAO;IACPC,MAAA,EAAQ;IACRC,KAAA,EAAO;IACPC,YAAA,EAAc;IACdC,YAAA,EAAc;EAClB;EAMMC,aAAA,GAAgB;IAClBN,IAAA,EAAM;IACNC,KAAA,EAAO;IACPM,MAAA,EAAQ;IACRC,YAAA,EAAc;IACdC,UAAA,EAAY;IACZC,UAAA,EAAY;IACZC,UAAA,EAAY;IACZC,UAAA,EAAY;EAChB;EAMMC,eAAA,GAAkB;IACpBC,WAAA,EAAa;IACbC,kBAAA,EAAoB;IACpBC,SAAA,EAAW;IACXC,UAAA,EAAY;IACZC,WAAA,EAAa;EACjB;EAiJMC,QAAA,GAAW;EAGXC,UAAA,GAAa;EACbC,WAAA,GAAc;EACdC,QAAA,GAAW;EACXC,QAAA,GAAW;EACXC,cAAA,GAAiB;EAGjBC,WAAA,GAAc;EACdC,WAAA,GAAc;EACdC,WAAA,GAAc;EACdC,WAAA,GAAc;EAGdC,6BAAA,GAAgC;EAMhCC,gBAAA,GAA6C;IAC/C,CAACL,WAAW,GAAGM,gBAAA,CAAiBC,6BAAA;IAChC,CAACN,WAAW,GAAGK,gBAAA,CAAiBE,6BAAA;IAChC,CAACN,WAAW,GAAGI,gBAAA,CAAiBG;EACpC;EAMMC,cAAA,GAA2C;IAAA;IAE5C,IAAuCJ,gBAAA,CAAiBC,6BAAA;IACxD,IAAoCD,gBAAA,CAAiBC,6BAAA;IACrD,IAAuCD,gBAAA,CAAiBE,6BAAA;IACxD,IAAoCF,gBAAA,CAAiBE,6BAAA;IACrD,IAAuCF,gBAAA,CAAiBG,6BAAA;IACxD,IAAoCH,gBAAA,CAAiBG,6BAAA;IAAA;IAGrD,IAAyCH,gBAAA,CAAiBK,mCAAA;IAC1D,IAAyCL,gBAAA,CAAiBM,mCAAA;IAC1D,IAAyCN,gBAAA,CAAiBO;EAC/D;AAQO,SAASC,SAASC,WAAA,EACzB;EACU,MAAAC,IAAA,GAAO,IAAIC,WAAA,CAAYF,WAAW;EACtB,IAAAC,IAAA,CAAK,CAAC,MAEN3C,SAAA,EAER,UAAI6C,KAAA,CAAM,6BAA6B;EAG3C,MAAAC,MAAA,GAAS,IAAIF,WAAA,CAAYF,WAAA,EAAa,GAAG7C,eAAA,GAAkB+C,WAAA,CAAYG,iBAAiB;IAGxFC,MAAA,GAASF,MAAA,CAAO7C,UAAA,CAAWG,MAAM;IACjC6C,KAAA,GAAQH,MAAA,CAAO7C,UAAA,CAAWI,KAAK;IAC/B6C,WAAA,GAAcJ,MAAA,CAAO7C,UAAA,CAAWK,YAAY;IAG5C6C,WAAA,GAAc,IAAIP,WAAA,CACpBF,WAAA,EACAzC,UAAA,CAAWM,YAAA,GAAeqC,WAAA,CAAYG,iBAAA,EACtCjD,kBAAA,GAAqB8C,WAAA,CAAYG,iBAAA;IAC/BK,WAAA,GAAcD,WAAA,CAAY9B,QAAQ;EAGxC,IAAI+B,WAAA,GAAc7B,WAAA,EAClB;IACU,MAAA8B,MAAA,GAASF,WAAA,CAAY3C,aAAA,CAAcC,MAAM;IAG/C,IAAI4C,MAAA,KAAWvB,WAAA,EACf;MACU,MAAAwB,eAAA,GAAiBtB,gBAAA,CAAiBqB,MAAM;QAExCE,WAAA,GAAa3D,cAAA,GAAiBC,eAAA;QAC9B2D,OAAA,GAAU,IAAIC,UAAA,CAAWf,WAAA,EAAaa,WAAU;MAS/C,QAPU,IAAIG,yBAAA,CAA0BF,OAAA,EAAS;QACpDG,MAAA,EAAQL,eAAA;QACRL,KAAA;QACAD,MAAA;QACAY,MAAA,EAAQV;QAAA;MACX,EAEe;IACpB;IAGA,MAAMW,UAAA,GAAajE,cAAA,GAAiBC,eAAA;MAC9BiE,UAAA,GAAa,IAAIlB,WAAA,CACnBD,IAAA,CAAKoB,MAAA,EACLF,UAAA,EACA9D,oBAAA,GAAuB6C,WAAA,CAAYG,iBAAA;MACjCiB,UAAA,GAAaF,UAAA,CAAW/C,eAAA,CAAgBC,WAAW;MACnDiD,iBAAA,GAAoBH,UAAA,CAAW/C,eAAA,CAAgBE,kBAAkB;MACjEiD,QAAA,GAAWJ,UAAA,CAAW/C,eAAA,CAAgBG,SAAS;MAC/CiD,SAAA,GAAYL,UAAA,CAAW/C,eAAA,CAAgBI,UAAU;MAGjDiD,cAAA,GAAiB/B,cAAA,CAAe2B,UAAU;IAEhD,IAAII,cAAA,KAAmB,QAEnB,MAAM,IAAIvB,KAAA,CAAM,wDAAwDmB,UAAU,EAAE;IAExF,IAAIE,QAAA,KAAanC,6BAAA,EAGP,UAAIc,KAAA,CAAM,6CAA6C;IAEjE,IAAIoB,iBAAA,KAAsB,GAGhB,UAAIpB,KAAA,CAAM,8CAA8C;IAIlE,MAAMwB,YAAA,GAAe,IAAIC,KAAA,CACnB;MAAAC,UAAA,GAAa3E,cAAA,GACTC,eAAA,GACAE,oBAAA;IAEV,IAAIoE,SAAA,KAAc,GAGdE,YAAA,CAAaG,IAAA,CAAK,IAAIf,UAAA,CAAWf,WAAA,EAAa6B,UAAU,CAAC,OAG7D;MAGU,MAAAE,SAAA,GAAYC,kCAAA,CAAmCN,cAAc;MACnE,IAAIO,SAAA,GAAY;QACZC,UAAA,GAAa3B,KAAA;QACb4B,WAAA,GAAc7B,MAAA;MAElB,SAAS8B,CAAA,GAAI,GAAGA,CAAA,GAAI5B,WAAA,EAAa4B,CAAA,IACjC;QACI,MAAMC,iBAAA,GAAoBC,IAAA,CAAKC,GAAA,CAAI,GAAIL,UAAA,GAAa,IAAK,EAAE;UACrDM,kBAAA,GAAqBF,IAAA,CAAKC,GAAA,CAAI,GAAIJ,WAAA,GAAc,IAAK,EAAE;UAEvDM,SAAA,GAAYJ,iBAAA,GAAoBG,kBAAA,GAAqBT,SAAA;QAE3DE,SAAA,IAAaQ,SAAA,EAEbP,UAAA,GAAaA,UAAA,KAAe,GAC5BC,WAAA,GAAcA,WAAA,KAAgB;MAClC;MAEA,IAAIO,WAAA,GAAcb,UAAA;MAGT,SAAAO,CAAA,GAAI,GAAGA,CAAA,GAAIX,SAAA,EAAWW,CAAA,IAEdT,YAAA,CAAAG,IAAA,CAAK,IAAIf,UAAA,CAAWf,WAAA,EAAa0C,WAAA,EAAaT,SAAS,CAAC,GACrES,WAAA,IAAeT,SAAA;IAEvB;IAGA,OAAON,YAAA,CAAagB,GAAA,CAAKtB,MAAA,IAAW,IAAIL,yBAAA,CAA0BK,MAAA,EAAQ;MACtEJ,MAAA,EAAQS,cAAA;MACRnB,KAAA;MACAD,MAAA;MACAY,MAAA,EAAQV;IACX,EAAC;EACN;EACI,MAAAE,WAAA,GAAc5B,QAAA,GAGR,IAAIqB,KAAA,CAAM,uDAAuD,IAEvEO,WAAA,GAAc3B,QAAA,GAGR,IAAIoB,KAAA,CAAM,6DAA6D,IAE7EO,WAAA,GAAc1B,cAAA,GAGR,IAAImB,KAAA,CAAM,sEAAsE,IAEtFO,WAAA,GAAc9B,UAAA,GAGR,IAAIuB,KAAA,CAAM,iEAAiE,IAG/E,IAAIA,KAAA,CAAM,mEAAmE;AACvF"},"metadata":{},"sourceType":"module","externalDependencies":[]}