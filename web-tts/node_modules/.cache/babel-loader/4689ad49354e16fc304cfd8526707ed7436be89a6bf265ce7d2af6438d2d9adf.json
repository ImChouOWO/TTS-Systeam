{"ast":null,"code":"import { Texture, settings, Rectangle, utils } from \"@pixi/core\";\nimport { Sprite } from \"@pixi/sprite\";\nimport { TextStyle } from \"@pixi/text\";\nimport { HTMLTextStyle } from \"./HTMLTextStyle.mjs\";\nconst _HTMLText = class _HTMLText2 extends Sprite {\n  /**\n   * @param {string} [text] - Text contents\n   * @param {PIXI.HTMLTextStyle|PIXI.TextStyle|PIXI.ITextStyle} [style] - Style setting to use.\n   *        Strongly recommend using an HTMLTextStyle object. Providing a PIXI.TextStyle\n   *        will convert the TextStyle to an HTMLTextStyle and will no longer be linked.\n   */\n  constructor(text = \"\", style = {}) {\n    super(Texture.EMPTY), this._text = null, this._style = null, this._autoResolution = !0, this.localStyleID = -1, this.dirty = !1, this._updateID = 0, this.ownsStyle = !1;\n    const image = new Image(),\n      texture = Texture.from(image, {\n        scaleMode: settings.SCALE_MODE,\n        resourceOptions: {\n          autoLoad: !1\n        }\n      });\n    texture.orig = new Rectangle(), texture.trim = new Rectangle(), this.texture = texture;\n    const nssvg = \"http://www.w3.org/2000/svg\",\n      nsxhtml = \"http://www.w3.org/1999/xhtml\",\n      svgRoot = document.createElementNS(nssvg, \"svg\"),\n      foreignObject = document.createElementNS(nssvg, \"foreignObject\"),\n      domElement = document.createElementNS(nsxhtml, \"div\"),\n      styleElement = document.createElementNS(nsxhtml, \"style\");\n    foreignObject.setAttribute(\"width\", \"10000\"), foreignObject.setAttribute(\"height\", \"10000\"), foreignObject.style.overflow = \"hidden\", svgRoot.appendChild(foreignObject), this.maxWidth = _HTMLText2.defaultMaxWidth, this.maxHeight = _HTMLText2.defaultMaxHeight, this._domElement = domElement, this._styleElement = styleElement, this._svgRoot = svgRoot, this._foreignObject = foreignObject, this._foreignObject.appendChild(styleElement), this._foreignObject.appendChild(domElement), this._image = image, this._loadImage = new Image(), this._autoResolution = _HTMLText2.defaultAutoResolution, this._resolution = _HTMLText2.defaultResolution ?? settings.RESOLUTION, this.text = text, this.style = style;\n  }\n  /**\n   * Calculate the size of the output text without actually drawing it.\n   * This includes the `padding` in the `style` object.\n   * This can be used as a fast-pass to do things like text-fitting.\n   * @param {object} [overrides] - Overrides for the text, style, and resolution.\n   * @param {string} [overrides.text] - The text to measure, if not specified, the current text is used.\n   * @param {PIXI.HTMLTextStyle} [overrides.style] - The style to measure, if not specified, the current style is used.\n   * @param {number} [overrides.resolution] - The resolution to measure, if not specified, the current resolution is used.\n   * @returns {PIXI.ISize} Width and height of the measured text.\n   */\n  measureText(overrides) {\n    const {\n      text,\n      style,\n      resolution\n    } = Object.assign({\n      text: this._text,\n      style: this._style,\n      resolution: this._resolution\n    }, overrides);\n    Object.assign(this._domElement, {\n      innerHTML: text,\n      style: style.toCSS(resolution)\n    }), this._styleElement.textContent = style.toGlobalCSS(), document.body.appendChild(this._svgRoot);\n    const contentBounds = this._domElement.getBoundingClientRect();\n    this._svgRoot.remove();\n    const {\n      width,\n      height\n    } = contentBounds;\n    (width > this.maxWidth || height > this.maxHeight) && console.warn(\"[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.\");\n    const contentWidth = Math.min(this.maxWidth, Math.ceil(width)),\n      contentHeight = Math.min(this.maxHeight, Math.ceil(height));\n    return this._svgRoot.setAttribute(\"width\", contentWidth.toString()), this._svgRoot.setAttribute(\"height\", contentHeight.toString()), text !== this._text && (this._domElement.innerHTML = this._text), style !== this._style && (Object.assign(this._domElement, {\n      style: this._style?.toCSS(resolution)\n    }), this._styleElement.textContent = this._style?.toGlobalCSS()), {\n      width: contentWidth + style.padding * 2,\n      height: contentHeight + style.padding * 2\n    };\n  }\n  /**\n   * Manually refresh the text.\n   * @public\n   * @param {boolean} respectDirty - Whether to abort updating the\n   *        text if the Text isn't dirty and the function is called.\n   */\n  async updateText(respectDirty = !0) {\n    const {\n      style,\n      _image: image,\n      _loadImage: loadImage\n    } = this;\n    if (this.localStyleID !== style.styleID && (this.dirty = !0, this.localStyleID = style.styleID), !this.dirty && respectDirty) return;\n    const {\n      width,\n      height\n    } = this.measureText();\n    image.width = loadImage.width = Math.ceil(Math.max(1, width)), image.height = loadImage.height = Math.ceil(Math.max(1, height)), this._updateID++;\n    const updateID = this._updateID;\n    await new Promise(resolve => {\n      loadImage.onload = async () => {\n        if (updateID < this._updateID) {\n          resolve();\n          return;\n        }\n        await style.onBeforeDraw(), image.src = loadImage.src, loadImage.onload = null, loadImage.src = \"\", this.updateTexture(), resolve();\n      };\n      const svgURL = new XMLSerializer().serializeToString(this._svgRoot);\n      loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;\n    });\n  }\n  /** The raw image element that is rendered under-the-hood. */\n  get source() {\n    return this._image;\n  }\n  /**\n   * Update the texture resource.\n   * @private\n   */\n  updateTexture() {\n    const {\n        style,\n        texture,\n        _image: image,\n        resolution\n      } = this,\n      {\n        padding\n      } = style,\n      {\n        baseTexture\n      } = texture;\n    texture.trim.width = texture._frame.width = image.width / resolution, texture.trim.height = texture._frame.height = image.height / resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - padding * 2, texture.orig.height = texture._frame.height - padding * 2, this._onTextureUpdate(), baseTexture.setRealSize(image.width, image.height, resolution), this.dirty = !1;\n  }\n  /**\n   * Renders the object using the WebGL renderer\n   * @param {PIXI.Renderer} renderer - The renderer\n   * @private\n   */\n  _render(renderer) {\n    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), super._render(renderer);\n  }\n  /**\n   * Renders the object using the Canvas Renderer.\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */\n  _renderCanvas(renderer) {\n    this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0), this.updateText(!0), super._renderCanvas(renderer);\n  }\n  /**\n   * Get the local bounds.\n   * @param {PIXI.Rectangle} rect - Input rectangle.\n   * @returns {PIXI.Rectangle} Local bounds\n   */\n  getLocalBounds(rect) {\n    return this.updateText(!0), super.getLocalBounds(rect);\n  }\n  _calculateBounds() {\n    this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData);\n  }\n  /**\n   * Handle dirty style changes\n   * @private\n   */\n  _onStyleChange() {\n    this.dirty = !0;\n  }\n  /**\n   * Destroy this Text object. Don't use after calling.\n   * @param {boolean|object} options - Same as Sprite destroy options.\n   */\n  destroy(options) {\n    typeof options == \"boolean\" && (options = {\n      children: options\n    }), options = Object.assign({}, _HTMLText2.defaultDestroyOptions, options), super.destroy(options);\n    const forceClear = null;\n    this.ownsStyle && this._style?.cleanFonts(), this._style = forceClear, this._svgRoot?.remove(), this._svgRoot = forceClear, this._domElement?.remove(), this._domElement = forceClear, this._foreignObject?.remove(), this._foreignObject = forceClear, this._styleElement?.remove(), this._styleElement = forceClear, this._loadImage.src = \"\", this._loadImage.onload = null, this._loadImage = forceClear, this._image.src = \"\", this._image = forceClear;\n  }\n  /**\n   * Get the width in pixels.\n   * @member {number}\n   */\n  get width() {\n    return this.updateText(!0), Math.abs(this.scale.x) * this._image.width / this.resolution;\n  }\n  set width(value) {\n    this.updateText(!0);\n    const s = utils.sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._image.width / this.resolution, this._width = value;\n  }\n  /**\n   * Get the height in pixels.\n   * @member {number}\n   */\n  get height() {\n    return this.updateText(!0), Math.abs(this.scale.y) * this._image.height / this.resolution;\n  }\n  set height(value) {\n    this.updateText(!0);\n    const s = utils.sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._image.height / this.resolution, this._height = value;\n  }\n  /** The base style to render with text. */\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    this._style !== style && (style = style || {}, style instanceof HTMLTextStyle ? (this.ownsStyle = !1, this._style = style) : style instanceof TextStyle ? (console.warn(\"[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle\"), this.ownsStyle = !0, this._style = HTMLTextStyle.from(style)) : (this.ownsStyle = !0, this._style = new HTMLTextStyle(style)), this.localStyleID = -1, this.dirty = !0);\n  }\n  /**\n   * Contents of text. This can be HTML text and include tags.\n   * @example\n   * const text = new HTMLText('This is a <em>styled</em> text!');\n   * @member {string}\n   */\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text === \"\" || text === null || text === void 0 ? \" \" : text), text = this.sanitiseText(text), this._text !== text && (this._text = text, this.dirty = !0);\n  }\n  /**\n   * The resolution / device pixel ratio of the canvas.\n   * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n   * @member {number}\n   * @default 1\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = !1, this._resolution !== value && (this._resolution = value, this.dirty = !0);\n  }\n  /**\n   * Sanitise text - replace `<br>` with `<br/>`, `&nbsp;` with `&#160;`\n   * @param text\n   * @see https://www.sitepoint.com/community/t/xhtml-1-0-transitional-xml-parsing-error-entity-nbsp-not-defined/3392/3\n   */\n  sanitiseText(text) {\n    return text.replace(/<br>/gi, \"<br/>\").replace(/<hr>/gi, \"<hr/>\").replace(/&nbsp;/gi, \"&#160;\");\n  }\n};\n_HTMLText.defaultDestroyOptions = {\n  texture: !0,\n  children: !1,\n  baseTexture: !0\n}, /** Default maxWidth, set at construction */\n_HTMLText.defaultMaxWidth = 2024, /** Default maxHeight, set at construction */\n_HTMLText.defaultMaxHeight = 2024, /** Default autoResolution for all HTMLText objects */\n_HTMLText.defaultAutoResolution = !0;\nlet HTMLText = _HTMLText;\nexport { HTMLText };","map":{"version":3,"names":["_HTMLText","_HTMLText2","Sprite","constructor","text","style","Texture","EMPTY","_text","_style","_autoResolution","localStyleID","dirty","_updateID","ownsStyle","image","Image","texture","from","scaleMode","settings","SCALE_MODE","resourceOptions","autoLoad","orig","Rectangle","trim","nssvg","nsxhtml","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","setAttribute","overflow","appendChild","maxWidth","defaultMaxWidth","maxHeight","defaultMaxHeight","_domElement","_styleElement","_svgRoot","_foreignObject","_image","_loadImage","defaultAutoResolution","_resolution","defaultResolution","RESOLUTION","measureText","overrides","resolution","Object","assign","innerHTML","toCSS","textContent","toGlobalCSS","body","contentBounds","getBoundingClientRect","remove","width","height","console","warn","contentWidth","Math","min","ceil","contentHeight","toString","padding","updateText","respectDirty","loadImage","styleID","max","updateID","Promise","resolve","onload","onBeforeDraw","src","updateTexture","svgURL","XMLSerializer","serializeToString","encodeURIComponent","source","baseTexture","_frame","x","y","_onTextureUpdate","setRealSize","_render","renderer","_renderCanvas","getLocalBounds","rect","_calculateBounds","calculateVertices","_bounds","addQuad","vertexData","_onStyleChange","destroy","options","children","defaultDestroyOptions","forceClear","cleanFonts","abs","scale","value","s","utils","sign","_width","_height","HTMLTextStyle","TextStyle","String","sanitiseText","replace","HTMLText"],"sources":["C:\\Users\\Owner\\Desktop\\python\\TTS-systeam\\voice\\web-tts\\node_modules\\pixi.js\\node_modules\\@pixi\\text-html\\src\\HTMLText.ts"],"sourcesContent":["import { Rectangle, settings, Texture, utils } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { TextStyle } from '@pixi/text';\nimport { HTMLTextStyle } from './HTMLTextStyle';\n\nimport type { ImageResource, IRenderer, ISize, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { ITextStyle } from '@pixi/text';\n\n/**\n * Alternative to {@link PIXI.Text|Text} but supports multi-style HTML text. There are\n * few key differences between this and {@link PIXI.Text|Text}:\n * <br>&bull; HTMLText not support {@link https://caniuse.com/mdn-svg_elements_foreignobject|Internet Explorer}.\n * <br>&bull; Rendering is text asynchronous. If statically rendering, listen to `update` event on BaseTexture.\n * <br>&bull; Does not support all style options (e.g., `lineJoin`, `leading`, `textBaseline`, `trim`, `miterLimit`,\n *   `fillGradientStops`, `fillGradientType`)\n * @example\n * import { HTMLText } from 'pixi.js';\n *\n * const text = new HTMLText(\"Hello <b>World</b>\", { fontSize: 20 });\n *\n * text.texture.baseTexture.on('update', () => {\n *   console.log('Text is redrawn!');\n * });\n * @class\n * @memberof PIXI\n * @extends PIXI.Sprite\n * @since 7.2.0\n */\nexport class HTMLText extends Sprite\n{\n    /**\n     * Default opens when destroying.\n     * @type {PIXI.IDestroyOptions}\n     * @property {boolean} [texture=true] - Whether to destroy the texture.\n     * @property {boolean} [children=false] - Whether to destroy the children.\n     * @property {boolean} [baseTexture=true] - Whether to destroy the base texture.\n     */\n    public static defaultDestroyOptions: IDestroyOptions = {\n        texture: true,\n        children: false,\n        baseTexture: true,\n    };\n\n    /** Default maxWidth, set at construction */\n    public static defaultMaxWidth = 2024;\n\n    /** Default maxHeight, set at construction */\n    public static defaultMaxHeight = 2024;\n\n    /** Default resolution, make sure autoResolution or defaultAutoResolution is `false`. */\n    public static defaultResolution: number | undefined;\n\n    /** Default autoResolution for all HTMLText objects */\n    public static defaultAutoResolution = true;\n\n    /** The maximum width in rendered pixels that the content can be, any larger will be hidden */\n    public maxWidth: number;\n\n    /** The maximum height in rendered pixels that the content can be, any larger will be hidden */\n    public maxHeight: number;\n\n    private _domElement: HTMLElement;\n    private _styleElement: HTMLElement;\n    private _svgRoot: SVGSVGElement;\n    private _foreignObject: SVGForeignObjectElement;\n    private _image: HTMLImageElement;\n    private _loadImage: HTMLImageElement;\n    private _resolution: number;\n    private _text: string | null = null;\n    private _style: HTMLTextStyle | null = null;\n    private _autoResolution = true;\n    private localStyleID = -1;\n    private dirty = false;\n    private _updateID = 0;\n\n    /** The HTMLTextStyle object is owned by this instance */\n    private ownsStyle = false;\n\n    /**\n     * @param {string} [text] - Text contents\n     * @param {PIXI.HTMLTextStyle|PIXI.TextStyle|PIXI.ITextStyle} [style] - Style setting to use.\n     *        Strongly recommend using an HTMLTextStyle object. Providing a PIXI.TextStyle\n     *        will convert the TextStyle to an HTMLTextStyle and will no longer be linked.\n     */\n    constructor(text = '', style: HTMLTextStyle | TextStyle | Partial<ITextStyle> = {})\n    {\n        super(Texture.EMPTY);\n\n        const image = new Image();\n        const texture = Texture.from<ImageResource>(image, {\n            scaleMode: settings.SCALE_MODE,\n            resourceOptions: {\n                autoLoad: false,\n            },\n        });\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        this.texture = texture;\n\n        const nssvg = 'http://www.w3.org/2000/svg';\n        const nsxhtml = 'http://www.w3.org/1999/xhtml';\n        const svgRoot = document.createElementNS(nssvg, 'svg');\n        const foreignObject = document.createElementNS(nssvg, 'foreignObject');\n        const domElement = document.createElementNS(nsxhtml, 'div');\n        const styleElement = document.createElementNS(nsxhtml, 'style');\n\n        // Arbitrary max size\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n        svgRoot.appendChild(foreignObject);\n\n        this.maxWidth = HTMLText.defaultMaxWidth;\n        this.maxHeight = HTMLText.defaultMaxHeight;\n        this._domElement = domElement;\n        this._styleElement = styleElement;\n        this._svgRoot = svgRoot;\n        this._foreignObject = foreignObject;\n        this._foreignObject.appendChild(styleElement);\n        this._foreignObject.appendChild(domElement);\n        this._image = image;\n        this._loadImage = new Image();\n        this._autoResolution = HTMLText.defaultAutoResolution;\n        this._resolution = HTMLText.defaultResolution ?? settings.RESOLUTION;\n        this.text = text;\n        this.style = style;\n    }\n\n    /**\n     * Calculate the size of the output text without actually drawing it.\n     * This includes the `padding` in the `style` object.\n     * This can be used as a fast-pass to do things like text-fitting.\n     * @param {object} [overrides] - Overrides for the text, style, and resolution.\n     * @param {string} [overrides.text] - The text to measure, if not specified, the current text is used.\n     * @param {PIXI.HTMLTextStyle} [overrides.style] - The style to measure, if not specified, the current style is used.\n     * @param {number} [overrides.resolution] - The resolution to measure, if not specified, the current resolution is used.\n     * @returns {PIXI.ISize} Width and height of the measured text.\n     */\n    measureText(overrides?: { text?: string, style?: HTMLTextStyle, resolution?: number }): ISize\n    {\n        const { text, style, resolution } = Object.assign({\n            text: this._text,\n            style: this._style,\n            resolution: this._resolution,\n        }, overrides);\n\n        Object.assign(this._domElement, {\n            innerHTML: text,\n            style: style.toCSS(resolution),\n        });\n        this._styleElement.textContent = style.toGlobalCSS();\n\n        // Measure the contents using the shadow DOM\n        document.body.appendChild(this._svgRoot);\n        const contentBounds = this._domElement.getBoundingClientRect();\n\n        this._svgRoot.remove();\n\n        const { width, height } = contentBounds;\n\n        if (process.env.DEBUG)\n        {\n            if (width > this.maxWidth || height > this.maxHeight)\n            {\n                console.warn('[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.');\n            }\n        }\n\n        const contentWidth = Math.min(this.maxWidth, Math.ceil(width));\n        const contentHeight = Math.min(this.maxHeight, Math.ceil(height));\n\n        this._svgRoot.setAttribute('width', contentWidth.toString());\n        this._svgRoot.setAttribute('height', contentHeight.toString());\n\n        // Undo the changes to the DOM element\n        if (text !== this._text)\n        {\n            this._domElement.innerHTML = this._text as string;\n        }\n        if (style !== this._style)\n        {\n            Object.assign(this._domElement, { style: this._style?.toCSS(resolution) });\n            this._styleElement.textContent = this._style?.toGlobalCSS() as string;\n        }\n\n        return {\n            width: contentWidth + (style.padding * 2),\n            height: contentHeight + (style.padding * 2),\n        };\n    }\n\n    /**\n     * Manually refresh the text.\n     * @public\n     * @param {boolean} respectDirty - Whether to abort updating the\n     *        text if the Text isn't dirty and the function is called.\n     */\n    async updateText(respectDirty = true): Promise<void>\n    {\n        const { style, _image: image, _loadImage: loadImage } = this;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        const { width, height } = this.measureText();\n\n        // Make sure canvas is at least 1x1 so it drawable\n        // for sub-pixel sizes, round up to avoid clipping\n        // we update both images, to make sure bounds are correct synchronously\n        image.width = loadImage.width = Math.ceil((Math.max(1, width)));\n        image.height = loadImage.height = Math.ceil((Math.max(1, height)));\n\n        this._updateID++;\n\n        const updateID = this._updateID;\n\n        await new Promise<void>((resolve) =>\n        {\n            loadImage.onload = async () =>\n            {\n                if (updateID < this._updateID)\n                {\n                    resolve();\n\n                    return;\n                }\n\n                // Fake waiting for the image to load\n                await style.onBeforeDraw();\n\n                // Swap image and loadImage, we do this to avoid\n                // flashes between updateText calls, usually when\n                // the onload time is longer than updateText time\n                image.src = loadImage.src;\n                loadImage.onload = null;\n                loadImage.src = '';\n\n                // Force update the texture\n                this.updateTexture();\n                resolve();\n            };\n            const svgURL = new XMLSerializer().serializeToString(this._svgRoot);\n\n            loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;\n        });\n    }\n\n    /** The raw image element that is rendered under-the-hood. */\n    public get source(): HTMLImageElement\n    {\n        return this._image;\n    }\n\n    /**\n     * Update the texture resource.\n     * @private\n     */\n    updateTexture()\n    {\n        const { style, texture, _image: image, resolution } = this;\n        const { padding } = style;\n        const { baseTexture } = texture;\n\n        texture.trim.width = texture._frame.width = image.width / resolution;\n        texture.trim.height = texture._frame.height = image.height / resolution;\n        texture.trim.x = -padding;\n        texture.trim.y = -padding;\n\n        texture.orig.width = texture._frame.width - (padding * 2);\n        texture.orig.height = texture._frame.height - (padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        baseTexture.setRealSize(image.width, image.height, resolution);\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param {PIXI.Renderer} renderer - The renderer\n     * @private\n     */\n    _render(renderer: Renderer)\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._render(renderer);\n    }\n\n    /**\n     * Renders the object using the Canvas Renderer.\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer: IRenderer)\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        super._renderCanvas(renderer);\n    }\n\n    /**\n     * Get the local bounds.\n     * @param {PIXI.Rectangle} rect - Input rectangle.\n     * @returns {PIXI.Rectangle} Local bounds\n     */\n    getLocalBounds(rect: Rectangle)\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds(rect);\n    }\n\n    _calculateBounds()\n    {\n        this.updateText(true);\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        (this as any)._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Handle dirty style changes\n     * @private\n     */\n    _onStyleChange()\n    {\n        this.dirty = true;\n    }\n\n    /**\n     * Destroy this Text object. Don't use after calling.\n     * @param {boolean|object} options - Same as Sprite destroy options.\n     */\n    destroy(options?: boolean | IDestroyOptions | undefined)\n    {\n        if (typeof options === 'boolean')\n        {\n            options = { children: options };\n        }\n\n        options = Object.assign({}, HTMLText.defaultDestroyOptions, options);\n\n        super.destroy(options);\n\n        const forceClear: any = null;\n\n        // Remove any loaded fonts if we created the HTMLTextStyle\n        if (this.ownsStyle)\n        {\n            this._style?.cleanFonts();\n        }\n        this._style = forceClear;\n        this._svgRoot?.remove();\n        this._svgRoot = forceClear;\n        this._domElement?.remove();\n        this._domElement = forceClear;\n        this._foreignObject?.remove();\n        this._foreignObject = forceClear;\n        this._styleElement?.remove();\n        this._styleElement = forceClear;\n\n        this._loadImage.src = '';\n        this._loadImage.onload = null;\n        this._loadImage = forceClear;\n        this._image.src = '';\n        this._image = forceClear;\n    }\n\n    /**\n     * Get the width in pixels.\n     * @member {number}\n     */\n    get width()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._image.width / this.resolution;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._image.width / this.resolution;\n        this._width = value;\n    }\n\n    /**\n     * Get the height in pixels.\n     * @member {number}\n     */\n    get height()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._image.height / this.resolution;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._image.height / this.resolution;\n        this._height = value;\n    }\n\n    /** The base style to render with text. */\n    get style(): HTMLTextStyle\n    {\n        return this._style as HTMLTextStyle;\n    }\n\n    set style(style: HTMLTextStyle | TextStyle | Partial<ITextStyle>) // eslint-disable-line require-jsdoc\n    {\n        // Don't do anything if we're re-assigning\n        if (this._style === style)\n        {\n            return;\n        }\n\n        style = style || {};\n\n        if (style instanceof HTMLTextStyle)\n        {\n            this.ownsStyle = false;\n            this._style = style;\n        }\n        // Clone TextStyle\n        else if (style instanceof TextStyle)\n        {\n            console.warn('[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle');\n\n            this.ownsStyle = true;\n            this._style = HTMLTextStyle.from(style);\n        }\n        else\n        {\n            this.ownsStyle = true;\n            this._style = new HTMLTextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /**\n     * Contents of text. This can be HTML text and include tags.\n     * @example\n     * const text = new HTMLText('This is a <em>styled</em> text!');\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(text) // eslint-disable-line require-jsdoc\n    {\n        text = String(text === '' || text === null || text === undefined ? ' ' : text);\n        text = this.sanitiseText(text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @member {number}\n     * @default 1\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(value: number) // eslint-disable-line require-jsdoc\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n\n    /**\n     * Sanitise text - replace `<br>` with `<br/>`, `&nbsp;` with `&#160;`\n     * @param text\n     * @see https://www.sitepoint.com/community/t/xhtml-1-0-transitional-xml-parsing-error-entity-nbsp-not-defined/3392/3\n     */\n    private sanitiseText(text: string): string\n    {\n        return text\n            .replace(/<br>/gi, '<br/>')\n            .replace(/<hr>/gi, '<hr/>')\n            .replace(/&nbsp;/gi, '&#160;');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}