{"ast":null,"code":"import { Matrix, Rectangle, RenderTexture, utils, BaseTexture, Texture } from \"@pixi/core\";\nimport { DisplayObject } from \"@pixi/display\";\nimport { Sprite } from \"@pixi/sprite\";\nconst _tempMatrix = new Matrix();\nDisplayObject.prototype._cacheAsBitmap = !1;\nDisplayObject.prototype._cacheData = null;\nDisplayObject.prototype._cacheAsBitmapResolution = null;\nDisplayObject.prototype._cacheAsBitmapMultisample = null;\nclass CacheData {\n  constructor() {\n    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;\n  }\n}\nObject.defineProperties(DisplayObject.prototype, {\n  /**\n   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution\n   * but can be overriden for performance. Lower values will reduce memory usage at the expense\n   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.\n   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.\n   * @member {number|null} cacheAsBitmapResolution\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   */\n  cacheAsBitmapResolution: {\n    get() {\n      return this._cacheAsBitmapResolution;\n    },\n    set(resolution) {\n      resolution !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = resolution, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  /**\n   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's\n   * sample count is used.\n   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.\n   * @member {number|null} cacheAsBitmapMultisample\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   */\n  cacheAsBitmapMultisample: {\n    get() {\n      return this._cacheAsBitmapMultisample;\n    },\n    set(multisample) {\n      multisample !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = multisample, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  /**\n   * Set this to true if you want this display object to be cached as a bitmap.\n   * This basically takes a snapshot of the display object as it is at that moment. It can\n   * provide a performance benefit for complex static displayObjects.\n   * To remove simply set this property to `false`\n   *\n   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true\n   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  cacheAsBitmap: {\n    get() {\n      return this._cacheAsBitmap;\n    },\n    set(value) {\n      if (this._cacheAsBitmap === value) return;\n      this._cacheAsBitmap = value;\n      let data;\n      value ? (this._cacheData || (this._cacheData = new CacheData()), data = this._cacheData, data.originalRender = this.render, data.originalRenderCanvas = this.renderCanvas, data.originalUpdateTransform = this.updateTransform, data.originalCalculateBounds = this.calculateBounds, data.originalGetLocalBounds = this.getLocalBounds, data.originalDestroy = this.destroy, data.originalContainsPoint = this.containsPoint, data.originalMask = this._mask, data.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (data = this._cacheData, data.sprite && this._destroyCachedDisplayObject(), this.render = data.originalRender, this.renderCanvas = data.originalRenderCanvas, this.calculateBounds = data.originalCalculateBounds, this.getLocalBounds = data.originalGetLocalBounds, this.destroy = data.originalDestroy, this.updateTransform = data.originalUpdateTransform, this.containsPoint = data.originalContainsPoint, this._mask = data.originalMask, this.filterArea = data.originalFilterArea);\n    }\n  }\n});\nDisplayObject.prototype._renderCached = function (renderer) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(renderer), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(renderer));\n};\nDisplayObject.prototype._initCachedDisplayObject = function (renderer) {\n  if (this._cacheData?.sprite) return;\n  const cacheAlpha = this.alpha;\n  this.alpha = 1, renderer.batch.flush();\n  const bounds = this.getLocalBounds(new Rectangle(), !0);\n  if (this.filters?.length) {\n    const padding = this.filters[0].padding;\n    bounds.pad(padding);\n  }\n  const resolution = this.cacheAsBitmapResolution || renderer.resolution;\n  bounds.ceil(resolution), bounds.width = Math.max(bounds.width, 1 / resolution), bounds.height = Math.max(bounds.height, 1 / resolution);\n  const cachedRenderTexture = renderer.renderTexture.current,\n    cachedSourceFrame = renderer.renderTexture.sourceFrame.clone(),\n    cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone(),\n    cachedProjectionTransform = renderer.projection.transform,\n    renderTexture = RenderTexture.create({\n      width: bounds.width,\n      height: bounds.height,\n      resolution,\n      multisample: this.cacheAsBitmapMultisample ?? renderer.multisample\n    }),\n    textureCacheId = `cacheAsBitmap_${utils.uid()}`;\n  this._cacheData.textureCacheId = textureCacheId, BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), Texture.addToCache(renderTexture, textureCacheId);\n  const m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);\n  this.render = this._cacheData.originalRender, renderer.render(this, {\n    renderTexture,\n    clear: !0,\n    transform: m,\n    skipUpdateTransform: !1\n  }), renderer.framebuffer.blit(), renderer.projection.transform = cachedProjectionTransform, renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = cacheAlpha;\n  const cachedSprite = new Sprite(renderTexture);\n  cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -(bounds.x / bounds.width), cachedSprite.anchor.y = -(bounds.y / bounds.height), cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\nDisplayObject.prototype._renderCachedCanvas = function (renderer) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(renderer), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(renderer));\n};\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function (renderer) {\n  if (this._cacheData?.sprite) return;\n  const bounds = this.getLocalBounds(new Rectangle(), !0),\n    cacheAlpha = this.alpha;\n  this.alpha = 1;\n  const cachedRenderTarget = renderer.canvasContext.activeContext,\n    cachedProjectionTransform = renderer._projTransform,\n    resolution = this.cacheAsBitmapResolution || renderer.resolution;\n  bounds.ceil(resolution), bounds.width = Math.max(bounds.width, 1 / resolution), bounds.height = Math.max(bounds.height, 1 / resolution);\n  const renderTexture = RenderTexture.create({\n      width: bounds.width,\n      height: bounds.height,\n      resolution\n    }),\n    textureCacheId = `cacheAsBitmap_${utils.uid()}`;\n  this._cacheData.textureCacheId = textureCacheId, BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), Texture.addToCache(renderTexture, textureCacheId);\n  const m = _tempMatrix;\n  this.transform.localTransform.copyTo(m), m.invert(), m.tx -= bounds.x, m.ty -= bounds.y, this.renderCanvas = this._cacheData.originalRenderCanvas, renderer.render(this, {\n    renderTexture,\n    clear: !0,\n    transform: m,\n    skipUpdateTransform: !1\n  }), renderer.canvasContext.activeContext = cachedRenderTarget, renderer._projTransform = cachedProjectionTransform, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = cacheAlpha;\n  const cachedSprite = new Sprite(renderTexture);\n  cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -(bounds.x / bounds.width), cachedSprite.anchor.y = -(bounds.y / bounds.height), cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = renderer._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\nDisplayObject.prototype._calculateCachedBounds = function () {\n  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;\n};\nDisplayObject.prototype._getCachedLocalBounds = function () {\n  return this._cacheData.sprite.getLocalBounds(null);\n};\nDisplayObject.prototype._destroyCachedDisplayObject = function () {\n  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;\n};\nDisplayObject.prototype._cacheAsBitmapDestroy = function (options) {\n  this.cacheAsBitmap = !1, this.destroy(options);\n};\nexport { CacheData };","map":{"version":3,"names":["_tempMatrix","Matrix","DisplayObject","prototype","_cacheAsBitmap","_cacheData","_cacheAsBitmapResolution","_cacheAsBitmapMultisample","CacheData","constructor","textureCacheId","originalRender","originalRenderCanvas","originalCalculateBounds","originalGetLocalBounds","originalUpdateTransform","originalDestroy","originalMask","originalFilterArea","originalContainsPoint","sprite","Object","defineProperties","cacheAsBitmapResolution","get","set","resolution","cacheAsBitmap","cacheAsBitmapMultisample","multisample","value","data","render","renderCanvas","updateTransform","calculateBounds","getLocalBounds","destroy","containsPoint","_mask","filterArea","_renderCached","_renderCachedCanvas","_cacheAsBitmapDestroy","_destroyCachedDisplayObject","renderer","visible","worldAlpha","renderable","_initCachedDisplayObject","transform","_worldID","_render","cacheAlpha","alpha","batch","flush","bounds","Rectangle","filters","length","padding","pad","ceil","width","Math","max","height","cachedRenderTexture","renderTexture","current","cachedSourceFrame","sourceFrame","clone","cachedDestinationFrame","destinationFrame","cachedProjectionTransform","projection","RenderTexture","create","utils","uid","BaseTexture","addToCache","baseTexture","Texture","m","localTransform","copyTo","invert","translate","x","y","clear","skipUpdateTransform","framebuffer","blit","bind","displayObjectUpdateTransform","_calculateCachedBounds","_getCachedLocalBounds","cachedSprite","Sprite","worldTransform","anchor","_bounds","_parentID","parent","enableTempParent","disableTempParent","_initCachedDisplayObjectCanvas","_renderCanvas","cachedRenderTarget","canvasContext","activeContext","_projTransform","tx","ty","_tempDisplayObjectParent","_calculateBounds","updateID","_boundsID","_texture","removeFromCache","options"],"sources":["C:\\Users\\Owner\\Desktop\\python\\TTS-systeam\\voice\\web-tts\\node_modules\\pixi.js\\node_modules\\@pixi\\mixin-cache-as-bitmap\\src\\index.ts"],"sourcesContent":["/// <reference path=\"../global.d.ts\" />\nimport { BaseTexture, Matrix, Rectangle, RenderTexture, Texture, utils } from '@pixi/core';\nimport { DisplayObject } from '@pixi/display';\nimport { Sprite } from '@pixi/sprite';\n\nimport type {\n    ICanvasRenderingContext2D,\n    IPointData,\n    IRenderer,\n    MaskData,\n    MSAA_QUALITY,\n    Renderer,\n} from '@pixi/core';\nimport type { Container, IDestroyOptions } from '@pixi/display';\n\n// Don't import CanvasRender to remove dependency on this optional package\n// this type should satisify these requirements for cacheAsBitmap types\ninterface CanvasRenderer extends IRenderer\n{\n    canvasContext: {\n        activeContext: ICanvasRenderingContext2D;\n    }\n}\n\nconst _tempMatrix = new Matrix();\n\nDisplayObject.prototype._cacheAsBitmap = false;\nDisplayObject.prototype._cacheData = null;\nDisplayObject.prototype._cacheAsBitmapResolution = null;\nDisplayObject.prototype._cacheAsBitmapMultisample = null;\n\n// figured there's no point adding ALL the extra variables to prototype.\n// this model can hold the information needed. This can also be generated on demand as\n// most objects are not cached as bitmaps.\n/**\n * @class\n * @ignore\n * @private\n */\nexport class CacheData\n{\n    public textureCacheId: string;\n    public originalRender: (renderer: Renderer) => void;\n    public originalRenderCanvas: (renderer: IRenderer) => void;\n    public originalCalculateBounds: () => void;\n    public originalGetLocalBounds: (rect?: Rectangle) => Rectangle;\n    public originalUpdateTransform: () => void;\n    public originalDestroy: (options?: IDestroyOptions | boolean) => void;\n    public originalMask: Container | MaskData;\n    public originalFilterArea: Rectangle;\n    public originalContainsPoint: (point: IPointData) => boolean;\n    public sprite: Sprite;\n\n    constructor()\n    {\n        this.textureCacheId = null;\n\n        this.originalRender = null;\n        this.originalRenderCanvas = null;\n        this.originalCalculateBounds = null;\n        this.originalGetLocalBounds = null;\n\n        this.originalUpdateTransform = null;\n        this.originalDestroy = null;\n        this.originalMask = null;\n        this.originalFilterArea = null;\n        this.originalContainsPoint = null;\n        this.sprite = null;\n    }\n}\n\nObject.defineProperties(DisplayObject.prototype, {\n    /**\n     * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution\n     * but can be overriden for performance. Lower values will reduce memory usage at the expense\n     * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.\n     * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.\n     * @member {number|null} cacheAsBitmapResolution\n     * @memberof PIXI.DisplayObject#\n     * @default null\n     */\n    cacheAsBitmapResolution: {\n        get(): number | null\n        {\n            return this._cacheAsBitmapResolution;\n        },\n        set(resolution: number | null): void\n        {\n            if (resolution === this._cacheAsBitmapResolution)\n            {\n                return;\n            }\n\n            this._cacheAsBitmapResolution = resolution;\n\n            if (this.cacheAsBitmap)\n            {\n                // Toggle to re-render at the new resolution\n                this.cacheAsBitmap = false;\n                this.cacheAsBitmap = true;\n            }\n        },\n    },\n\n    /**\n     * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's\n     * sample count is used.\n     * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.\n     * @member {number|null} cacheAsBitmapMultisample\n     * @memberof PIXI.DisplayObject#\n     * @default null\n     */\n    cacheAsBitmapMultisample: {\n        get(): MSAA_QUALITY | null\n        {\n            return this._cacheAsBitmapMultisample;\n        },\n        set(multisample: MSAA_QUALITY | null): void\n        {\n            if (multisample === this._cacheAsBitmapMultisample)\n            {\n                return;\n            }\n\n            this._cacheAsBitmapMultisample = multisample;\n\n            if (this.cacheAsBitmap)\n            {\n                // Toggle to re-render with new multisample\n                this.cacheAsBitmap = false;\n                this.cacheAsBitmap = true;\n            }\n        },\n    },\n\n    /**\n     * Set this to true if you want this display object to be cached as a bitmap.\n     * This basically takes a snapshot of the display object as it is at that moment. It can\n     * provide a performance benefit for complex static displayObjects.\n     * To remove simply set this property to `false`\n     *\n     * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true\n     * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.\n     * @member {boolean}\n     * @memberof PIXI.DisplayObject#\n     */\n    cacheAsBitmap: {\n        get(): CacheData\n        {\n            return this._cacheAsBitmap;\n        },\n        set(value: CacheData): void\n        {\n            if (this._cacheAsBitmap === value)\n            {\n                return;\n            }\n\n            this._cacheAsBitmap = value;\n\n            let data: CacheData;\n\n            if (value)\n            {\n                if (!this._cacheData)\n                {\n                    this._cacheData = new CacheData();\n                }\n\n                data = this._cacheData;\n\n                data.originalRender = this.render;\n                data.originalRenderCanvas = this.renderCanvas;\n\n                data.originalUpdateTransform = this.updateTransform;\n                data.originalCalculateBounds = this.calculateBounds;\n                data.originalGetLocalBounds = this.getLocalBounds;\n\n                data.originalDestroy = this.destroy;\n\n                data.originalContainsPoint = this.containsPoint;\n\n                data.originalMask = this._mask;\n                data.originalFilterArea = this.filterArea;\n\n                this.render = this._renderCached;\n                this.renderCanvas = this._renderCachedCanvas;\n\n                this.destroy = this._cacheAsBitmapDestroy;\n            }\n            else\n            {\n                data = this._cacheData;\n\n                if (data.sprite)\n                {\n                    this._destroyCachedDisplayObject();\n                }\n\n                this.render = data.originalRender;\n                this.renderCanvas = data.originalRenderCanvas;\n                this.calculateBounds = data.originalCalculateBounds;\n                this.getLocalBounds = data.originalGetLocalBounds;\n\n                this.destroy = data.originalDestroy;\n\n                this.updateTransform = data.originalUpdateTransform;\n                this.containsPoint = data.originalContainsPoint;\n\n                this._mask = data.originalMask;\n                this.filterArea = data.originalFilterArea;\n            }\n        },\n    },\n});\n\n/**\n * Renders a cached version of the sprite with WebGL\n * @private\n * @method _renderCached\n * @memberof PIXI.DisplayObject#\n * @param {PIXI.Renderer} renderer - the WebGL renderer\n */\nDisplayObject.prototype._renderCached = function _renderCached(renderer: Renderer): void\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n    {\n        return;\n    }\n\n    this._initCachedDisplayObject(renderer);\n\n    this._cacheData.sprite.transform._worldID = this.transform._worldID;\n    this._cacheData.sprite.worldAlpha = this.worldAlpha;\n    (this._cacheData.sprite as any)._render(renderer);\n};\n\n/**\n * Prepares the WebGL renderer to cache the sprite\n * @private\n * @method _initCachedDisplayObject\n * @memberof PIXI.DisplayObject#\n * @param {PIXI.Renderer} renderer - the WebGL renderer\n */\nDisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer: Renderer): void\n{\n    if (this._cacheData?.sprite)\n    {\n        return;\n    }\n\n    // make sure alpha is set to 1 otherwise it will get rendered as invisible!\n    const cacheAlpha = this.alpha;\n\n    this.alpha = 1;\n\n    // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)\n    renderer.batch.flush();\n    // this.filters= [];\n\n    // next we find the dimensions of the untransformed object\n    // this function also calls updatetransform on all its children as part of the measuring.\n    // This means we don't need to update the transform again in this function\n    // TODO pass an object to clone too? saves having to create a new one each time!\n    const bounds = (this as Container).getLocalBounds(new Rectangle(), true);\n\n    // add some padding!\n    if (this.filters?.length)\n    {\n        const padding = this.filters[0].padding;\n\n        bounds.pad(padding);\n    }\n\n    const resolution = this.cacheAsBitmapResolution || renderer.resolution;\n\n    bounds.ceil(resolution);\n    bounds.width = Math.max(bounds.width, 1 / resolution);\n    bounds.height = Math.max(bounds.height, 1 / resolution);\n\n    // for now we cache the current renderTarget that the WebGL renderer is currently using.\n    // this could be more elegant..\n    const cachedRenderTexture = renderer.renderTexture.current;\n    const cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();\n    const cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();\n    const cachedProjectionTransform = renderer.projection.transform;\n\n    // We also store the filter stack - I will definitely look to change how this works a little later down the line.\n    // const stack = renderer.filterManager.filterStack;\n\n    // this renderTexture will be used to store the cached DisplayObject\n    const renderTexture = RenderTexture.create({\n        width: bounds.width,\n        height: bounds.height,\n        resolution,\n        multisample: this.cacheAsBitmapMultisample ?? renderer.multisample,\n    });\n\n    const textureCacheId = `cacheAsBitmap_${utils.uid()}`;\n\n    this._cacheData.textureCacheId = textureCacheId;\n\n    BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);\n    Texture.addToCache(renderTexture, textureCacheId);\n\n    // need to set //\n    const m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);\n\n    // set all properties to there original so we can render to a texture\n    this.render = this._cacheData.originalRender;\n\n    renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });\n    renderer.framebuffer.blit();\n\n    // now restore the state be setting the new properties\n    renderer.projection.transform = cachedProjectionTransform;\n    renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);\n\n    // renderer.filterManager.filterStack = stack;\n\n    this.render = this._renderCached;\n    // the rest is the same as for Canvas\n    this.updateTransform = this.displayObjectUpdateTransform;\n    this.calculateBounds = this._calculateCachedBounds;\n    this.getLocalBounds = this._getCachedLocalBounds;\n\n    this._mask = null;\n    this.filterArea = null;\n    this.alpha = cacheAlpha;\n\n    // create our cached sprite\n    const cachedSprite = new Sprite(renderTexture);\n\n    cachedSprite.transform.worldTransform = this.transform.worldTransform;\n    cachedSprite.anchor.x = -(bounds.x / bounds.width);\n    cachedSprite.anchor.y = -(bounds.y / bounds.height);\n    cachedSprite.alpha = cacheAlpha;\n    cachedSprite._bounds = this._bounds;\n\n    this._cacheData.sprite = cachedSprite;\n\n    this.transform._parentID = -1;\n    // restore the transform of the cached sprite to avoid the nasty flicker..\n    if (!this.parent)\n    {\n        this.enableTempParent();\n        this.updateTransform();\n        this.disableTempParent(null);\n    }\n    else\n    {\n        this.updateTransform();\n    }\n\n    // map the hit test..\n    (this as Sprite).containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\n\n/**\n * Renders a cached version of the sprite with canvas\n * @private\n * @method _renderCachedCanvas\n * @memberof PIXI.DisplayObject#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer\n */\nDisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer: IRenderer): void\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n    {\n        return;\n    }\n\n    this._initCachedDisplayObjectCanvas(renderer);\n\n    this._cacheData.sprite.worldAlpha = this.worldAlpha;\n    (this._cacheData.sprite as any)._renderCanvas(renderer);\n};\n\n// TODO this can be the same as the WebGL version.. will need to do a little tweaking first though..\n/**\n * Prepares the Canvas renderer to cache the sprite\n * @private\n * @method _initCachedDisplayObjectCanvas\n * @memberof PIXI.DisplayObject#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer\n */\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(\n    renderer: CanvasRenderer\n): void\n{\n    if (this._cacheData?.sprite)\n    {\n        return;\n    }\n\n    // get bounds actually transforms the object for us already!\n    const bounds = (this as Container).getLocalBounds(new Rectangle(), true);\n\n    const cacheAlpha = this.alpha;\n\n    this.alpha = 1;\n\n    const cachedRenderTarget = renderer.canvasContext.activeContext;\n    const cachedProjectionTransform = (renderer as any)._projTransform;\n\n    const resolution = this.cacheAsBitmapResolution || renderer.resolution;\n\n    bounds.ceil(resolution);\n    bounds.width = Math.max(bounds.width, 1 / resolution);\n    bounds.height = Math.max(bounds.height, 1 / resolution);\n\n    const renderTexture = RenderTexture.create({\n        width: bounds.width,\n        height: bounds.height,\n        resolution\n    });\n\n    const textureCacheId = `cacheAsBitmap_${utils.uid()}`;\n\n    this._cacheData.textureCacheId = textureCacheId;\n\n    BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);\n    Texture.addToCache(renderTexture, textureCacheId);\n\n    // need to set //\n    const m = _tempMatrix;\n\n    this.transform.localTransform.copyTo(m);\n    m.invert();\n\n    m.tx -= bounds.x;\n    m.ty -= bounds.y;\n\n    // m.append(this.transform.worldTransform.)\n    // set all properties to there original so we can render to a texture\n    this.renderCanvas = this._cacheData.originalRenderCanvas;\n\n    renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });\n    // now restore the state be setting the new properties\n    renderer.canvasContext.activeContext = cachedRenderTarget;\n    (renderer as any)._projTransform = cachedProjectionTransform;\n\n    this.renderCanvas = this._renderCachedCanvas;\n    // the rest is the same as for WebGL\n    this.updateTransform = this.displayObjectUpdateTransform;\n    this.calculateBounds = this._calculateCachedBounds;\n    this.getLocalBounds = this._getCachedLocalBounds;\n\n    this._mask = null;\n    this.filterArea = null;\n    this.alpha = cacheAlpha;\n\n    // create our cached sprite\n    const cachedSprite = new Sprite(renderTexture);\n\n    cachedSprite.transform.worldTransform = this.transform.worldTransform;\n    cachedSprite.anchor.x = -(bounds.x / bounds.width);\n    cachedSprite.anchor.y = -(bounds.y / bounds.height);\n    cachedSprite.alpha = cacheAlpha;\n    cachedSprite._bounds = this._bounds;\n\n    this._cacheData.sprite = cachedSprite;\n\n    this.transform._parentID = -1;\n    // restore the transform of the cached sprite to avoid the nasty flicker..\n    if (!this.parent)\n    {\n        this.parent = (renderer as any)._tempDisplayObjectParent;\n        this.updateTransform();\n        this.parent = null;\n    }\n    else\n    {\n        this.updateTransform();\n    }\n\n    // map the hit test..\n    (this as Sprite).containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\n\n/**\n * Calculates the bounds of the cached sprite\n * @private\n * @method\n */\nDisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds(): void\n{\n    this._bounds.clear();\n    this._cacheData.sprite.transform._worldID = this.transform._worldID;\n    (this._cacheData.sprite as any)._calculateBounds();\n    this._bounds.updateID = (this as any)._boundsID;\n};\n\n/**\n * Gets the bounds of the cached sprite.\n * @private\n * @method\n * @returns {Rectangle} The local bounds.\n */\nDisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds(): Rectangle\n{\n    return this._cacheData.sprite.getLocalBounds(null);\n};\n\n/**\n * Destroys the cached sprite.\n * @private\n * @method\n */\nDisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject(): void\n{\n    this._cacheData.sprite._texture.destroy(true);\n    this._cacheData.sprite = null;\n\n    BaseTexture.removeFromCache(this._cacheData.textureCacheId);\n    Texture.removeFromCache(this._cacheData.textureCacheId);\n\n    this._cacheData.textureCacheId = null;\n};\n\n/**\n * Destroys the cached object.\n * @private\n * @method\n * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n *  have been set to that value.\n *  Used when destroying containers, see the Container.destroy method.\n */\nDisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options?: IDestroyOptions | boolean): void\n{\n    this.cacheAsBitmap = false;\n    this.destroy(options);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}