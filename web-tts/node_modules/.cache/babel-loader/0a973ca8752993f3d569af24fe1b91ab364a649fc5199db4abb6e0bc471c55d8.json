{"ast":null,"code":"import { ExtensionType, settings, VideoResource, BaseTexture, utils, extensions } from \"@pixi/core\";\nimport { checkDataUrl } from \"../../../utils/checkDataUrl.mjs\";\nimport { checkExtension } from \"../../../utils/checkExtension.mjs\";\nimport { LoaderParserPriority } from \"../LoaderParser.mjs\";\nimport { createTexture } from \"./utils/createTexture.mjs\";\nconst validVideoExtensions = [\".mp4\", \".m4v\", \".webm\", \".ogv\"],\n  validVideoMIMEs = [\"video/mp4\", \"video/webm\", \"video/ogg\"],\n  loadVideo = {\n    name: \"loadVideo\",\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.High\n    },\n    config: {\n      defaultAutoPlay: !0\n    },\n    test(url) {\n      return checkDataUrl(url, validVideoMIMEs) || checkExtension(url, validVideoExtensions);\n    },\n    async load(url, loadAsset, loader) {\n      let texture;\n      const blob = await (await settings.ADAPTER.fetch(url)).blob(),\n        blobURL = URL.createObjectURL(blob);\n      try {\n        const options = {\n            autoPlay: this.config.defaultAutoPlay,\n            ...loadAsset?.data?.resourceOptions\n          },\n          src = new VideoResource(blobURL, options);\n        await src.load();\n        const base = new BaseTexture(src, {\n          alphaMode: await utils.detectVideoAlphaMode(),\n          resolution: utils.getResolutionOfUrl(url),\n          ...loadAsset?.data\n        });\n        base.resource.src = url, texture = createTexture(base, loader, url), texture.baseTexture.once(\"destroyed\", () => {\n          URL.revokeObjectURL(blobURL);\n        });\n      } catch (e) {\n        throw URL.revokeObjectURL(blobURL), e;\n      }\n      return texture;\n    },\n    unload(texture) {\n      texture.destroy(!0);\n    }\n  };\nextensions.add(loadVideo);\nexport { loadVideo };","map":{"version":3,"names":["validVideoExtensions","validVideoMIMEs","loadVideo","name","extension","type","ExtensionType","LoadParser","priority","LoaderParserPriority","High","config","defaultAutoPlay","test","url","checkDataUrl","checkExtension","load","loadAsset","loader","texture","blob","settings","ADAPTER","fetch","blobURL","URL","createObjectURL","options","autoPlay","data","resourceOptions","src","VideoResource","base","BaseTexture","alphaMode","utils","detectVideoAlphaMode","resolution","getResolutionOfUrl","resource","createTexture","baseTexture","once","revokeObjectURL","e","unload","destroy","extensions","add"],"sources":["C:\\Users\\Owner\\Desktop\\python\\TTS-systeam\\voice\\web-tts\\node_modules\\pixi.js\\node_modules\\@pixi\\assets\\src\\loader\\parsers\\textures\\loadVideo.ts"],"sourcesContent":["import { BaseTexture, extensions, ExtensionType, settings, utils, VideoResource } from '@pixi/core';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, IVideoResourceOptions, Texture } from '@pixi/core';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validVideoExtensions = ['.mp4', '.m4v', '.webm', '.ogv'];\nconst validVideoMIMEs = [\n    'video/mp4',\n    'video/webm',\n    'video/ogg',\n];\n\n/**\n * Configuration for the `loadVideo` loader paarser.\n * @memberof PIXI\n * @see PIXI.loadVideo\n */\nexport interface LoadVideoConfig\n{\n    /**\n     * When set to `true`, the video will start playing automatically after being loaded,\n     * otherwise it will not start playing automatically.\n     * @default true\n     */\n    defaultAutoPlay: boolean;\n}\n\n/**\n * Loads videos into Textures.\n * @memberof PIXI\n */\nexport const loadVideo = {\n    name: 'loadVideo',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    config: {\n        defaultAutoPlay: true,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validVideoMIMEs) || checkExtension(url, validVideoExtensions);\n    },\n\n    async load(\n        url: string,\n        loadAsset?: ResolvedAsset<IBaseTextureOptions<IVideoResourceOptions>>,\n        loader?: Loader): Promise<Texture>\n    {\n        let texture: Texture;\n        const response = await settings.ADAPTER.fetch(url);\n        const blob = await response.blob();\n        const blobURL = URL.createObjectURL(blob);\n\n        try\n        {\n            const options = {\n                autoPlay: this.config.defaultAutoPlay,\n                ...loadAsset?.data?.resourceOptions,\n            };\n            const src = new VideoResource(blobURL, options);\n\n            await src.load();\n\n            const base = new BaseTexture(src, {\n                alphaMode: await utils.detectVideoAlphaMode(),\n                resolution: utils.getResolutionOfUrl(url),\n                ...loadAsset?.data,\n            });\n\n            base.resource.src = url;\n            texture = createTexture(base, loader, url);\n            texture.baseTexture.once('destroyed', () =>\n            {\n                URL.revokeObjectURL(blobURL);\n            });\n        }\n        catch (e)\n        {\n            URL.revokeObjectURL(blobURL);\n\n            throw e;\n        }\n\n        return texture;\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, IBaseTextureOptions<IVideoResourceOptions>, LoadVideoConfig>;\n\nextensions.add(loadVideo);\n"],"mappings":";;;;;AAWA,MAAMA,oBAAA,GAAuB,CAAC,QAAQ,QAAQ,SAAS,MAAM;EACvDC,eAAA,GAAkB,CACpB,aACA,cACA,YACJ;EAqBaC,SAAA,GAAY;IACrBC,IAAA,EAAM;IAENC,SAAA,EAAW;MACPC,IAAA,EAAMC,aAAA,CAAcC,UAAA;MACpBC,QAAA,EAAUC,oBAAA,CAAqBC;IACnC;IAEAC,MAAA,EAAQ;MACJC,eAAA,EAAiB;IACrB;IAEAC,KAAKC,GAAA,EACL;MACI,OAAOC,YAAA,CAAaD,GAAA,EAAKb,eAAe,KAAKe,cAAA,CAAeF,GAAA,EAAKd,oBAAoB;IACzF;IAEA,MAAMiB,KACFH,GAAA,EACAI,SAAA,EACAC,MAAA,EACJ;MACQ,IAAAC,OAAA;MAEJ,MAAMC,IAAA,GAAO,OADI,MAAMC,QAAA,CAASC,OAAA,CAAQC,KAAA,CAAMV,GAAG,GACrBO,IAAA,CAAK;QAC3BI,OAAA,GAAUC,GAAA,CAAIC,eAAA,CAAgBN,IAAI;MAGxC;QACI,MAAMO,OAAA,GAAU;YACZC,QAAA,EAAU,KAAKlB,MAAA,CAAOC,eAAA;YACtB,GAAGM,SAAA,EAAWY,IAAA,EAAMC;UAElB;UAAAC,GAAA,GAAM,IAAIC,aAAA,CAAcR,OAAA,EAASG,OAAO;QAE9C,MAAMI,GAAA,CAAIf,IAAA;QAEJ,MAAAiB,IAAA,GAAO,IAAIC,WAAA,CAAYH,GAAA,EAAK;UAC9BI,SAAA,EAAW,MAAMC,KAAA,CAAMC,oBAAA,CAAqB;UAC5CC,UAAA,EAAYF,KAAA,CAAMG,kBAAA,CAAmB1B,GAAG;UACxC,GAAGI,SAAA,EAAWY;QAAA,CACjB;QAEDI,IAAA,CAAKO,QAAA,CAAST,GAAA,GAAMlB,GAAA,EACpBM,OAAA,GAAUsB,aAAA,CAAcR,IAAA,EAAMf,MAAA,EAAQL,GAAG,GACzCM,OAAA,CAAQuB,WAAA,CAAYC,IAAA,CAAK,aAAa,MACtC;UACIlB,GAAA,CAAImB,eAAA,CAAgBpB,OAAO;QAAA,CAC9B;MAAA,SAEEqB,CAAA,EACP;QACQ,MAAApB,GAAA,CAAAmB,eAAA,CAAgBpB,OAAO,GAErBqB,CAAA;MACV;MAEO,OAAA1B,OAAA;IACX;IAEA2B,OAAO3B,OAAA,EACP;MACIA,OAAA,CAAQ4B,OAAA,CAAQ,EAAI;IACxB;EACJ;AAEAC,UAAA,CAAWC,GAAA,CAAIhD,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}